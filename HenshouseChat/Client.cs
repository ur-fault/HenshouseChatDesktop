using HenshouseChat.Extensions;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;

namespace HenshouseChat;

public class Client : IDisposable
{
    private readonly ClientWebSocket _ws;
    private readonly IAsymmetric _localAsymmetric;
    private readonly IAsymmetric _remoteAsymmetric;

    /// <summary>
    /// Symmetric key used to actually encrypt and decrypt messages
    /// Generated by the server
    /// </summary>
    public ISymmetric Symmetric { get; }

    private string _nickname = "";

    /// <summary>
    /// Nickname of the currently logged in user
    /// </summary>
    public string Nickname => _nickname;

    private int _id;
    public int Id => _id;

    private CancellationTokenSource? _listenCancellationTokenSource;

    private Action<ServerMessage>? _onMessage;
    private Action<Exception>? _onError;
    private Action? _onNormalClose;


    private Client(ClientWebSocket ws, IAsymmetric localAsymmetric, IAsymmetric remoteAsymmetric,
        ISymmetric symmetric) {
        _ws = ws;
        _localAsymmetric = localAsymmetric;
        _remoteAsymmetric = remoteAsymmetric;
        Symmetric = symmetric;
    }

    ~Client() {
        Dispose();
    }

    /// <summary>
    /// Connect to the server
    /// </summary>
    /// <param name="domain">Domain at which server is located</param>
    /// <param name="port">Port that server exposes</param>
    /// <param name="ct">Token used to cancel connecting</param>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException"></exception>
    public static async Task<Client> ConnectTo(string domain, int port = 25017,
        CancellationToken ct = default) {
        var ws = new ClientWebSocket();
        await ws.ConnectAsync(new Uri($"ws://{domain}:{port}"), ct);

        var remoteAsymmetric = new RSAOAEP(await ws.ReceiveSingleAsync(ct));
        var localAsymmetric = await Task.Run(() => new RSAOAEP(), ct);
        await ws.SendAsync(localAsymmetric.ExportPublic(), WebSocketMessageType.Binary, true, ct);

        var symmetric =
            new AESGCM(localAsymmetric.Decode(await ws.ReceiveSingleAsync(ct) ??
                                              throw new InvalidOperationException()));

        return new Client(ws, localAsymmetric, remoteAsymmetric, symmetric);
    }

    /// <summary>
    /// Run loop and listen for new messages from the server
    /// Changes [Nickname] as new messages come in
    /// </summary>
    /// <param name="onMessage">Callback on new message received</param>
    /// <param name="onError">Callback on error, after run will close loop</param>
    /// <param name="onNormalClose">Callback on normal close</param>
    /// <param name="ct"></param>
    /// <exception cref="InvalidOperationException"></exception>
    public async Task ListenAsync(Action<ServerMessage> onMessage, Action<Exception?>? onError = null,
        Action? onNormalClose = null, CancellationToken ct = default) {
        _listenCancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(ct);

        _onMessage = onMessage;
        _onError = onError;
        _onNormalClose = onNormalClose;

        try {
            while (true) {
                byte[]? encoded;
                try {
                    encoded = await _ws.ReceiveSingleAsync(_listenCancellationTokenSource.Token);
                }
                catch (WebSocketException e) {
                    _onError?.Invoke(e);
                    return;
                }

                if (encoded is null) {
                    _onNormalClose?.Invoke();
                    return;
                }

                string decoded;
                try {
                    decoded = Symmetric.DecodeToString(encoded);
                }
                catch (InvalidOperationException e) {
                    onError?.Invoke(e);
                    return;
                }

                var message = JsonSerializer.Deserialize<ServerMessage>(decoded) ??
                              throw new InvalidOperationException($"Could not parse {decoded}");
                _nickname = message.Recipient;

                _onMessage(message);
            }
        }
        catch (Exception e) when (e is TaskCanceledException or OperationCanceledException) {
            // ignored
        }
        finally {
            await Disconnect();
        }
    }

    private async Task SendAsync(byte[] data, CancellationToken ct = default) =>
        await _ws.SendAsync(Symmetric.Encode(data), WebSocketMessageType.Binary, true,
            CancellationToken.None);

    private async Task SendAsync(string data, CancellationToken ct = default) =>
        await SendAsync(Encoding.UTF8.GetBytes(data), ct);

    public async Task SendData(Message msg, CancellationToken ct = default) {
        await SendAsync(await Task.Run(() => JsonSerializer.Serialize(msg), ct), ct);
    }

    public async Task SendMessage(string content, CancellationToken ct = default) {
        await SendData(Message.NewMessage(content), ct);
    }

    public async Task SendCommand(string command, string args, CancellationToken ct = default) {
        await SendData(Message.NewCommand(command, args), ct);
    }

    public async Task Disconnect() {
        _listenCancellationTokenSource?.Cancel();
        try {
            await _ws.CloseAsync(WebSocketCloseStatus.NormalClosure, "Disconnecting", CancellationToken.None);
        }
        catch (WebSocketException) {
            // ignored
        }

        Dispose();
    }

    public async Task SetNickname(string newNick, CancellationToken ct = default) {
        _nickname = newNick;
        await SendCommand("nick", newNick, ct);
    }

    public void Dispose() {
        if (_localAsymmetric is IDisposable localAsymmetric)
            localAsymmetric.Dispose();

        if (_remoteAsymmetric is IDisposable remoteAsymmetric)
            remoteAsymmetric.Dispose();

        if (Symmetric is IDisposable symmetric)
            symmetric.Dispose();
    }
}